package AIHeroActions

import AddBot
import DrAndDeSpawn
import HeroSelection
import ClosureForGroups
import Shops
import ItemBuild

import Orders
import LastOrder
import Reference
import RegisterEvents

// States
bool array stunned
bool array canAttack
bool array isAttacking
bool array isRetreating
public bool array isCasting
bool array wannaBuy
bool array goShopping

unit array targetUnit
Order array lastOrders

function int.retreatTemporally(real time)
    if isAttacking[this]
        isRetreating[this] = true
        isAttacking[this] = false
        let pos = hero[this].getPos()
        doAfter(time) ->
            isRetreating[this] = false
            isAttacking[this] = true
            hero[this].issuePointOrderById(Orders.attack, pos)

// Shops
let merchants = CreateGroup()
let armsMerchants = CreateGroup()
let specialMerchants = CreateGroup()
let recipeMerchants = CreateGroup()
let bookStores = CreateGroup()

function int.getNearbyShop(unit h) returns unit
    group g = null
    unit shop = null
    switch this
        case MERCHANT
            g = merchants
        case ARMS_MERCHANT
            g = armsMerchants
        case SPECIAL_MERCHANT
            g = specialMerchants
        case RECIPES_MERCHANT
            g = recipeMerchants
        case BOOK_STORE
            g = bookStores
        case SECRET_MERCHANT
            shop = secretMerchant
    
    if shop == null
        let pos = h.getPos()
        var d = REAL_MAX

        for u in g
            let d2 = pos.distanceToSq(u.getPos())
            if d2 < d
                d = d2
                shop = u
    
    return shop

ItemBuild array itemBuilds

init
    forUnitsOfPlayer(players[PLAYER_NEUTRAL_PASSIVE], u -> begin
        switch u.getTypeId()
            case MERCHANT
                merchants.add(u)
            case ARMS_MERCHANT
                armsMerchants.add(u)
            case SPECIAL_MERCHANT
                specialMerchants.add(u)
            case RECIPES_MERCHANT
                recipeMerchants.add(u)
            case BOOK_STORE
                bookStores.add(u)
    end)
    
    addBotAction(bot -> begin
        let h = hero[bot]
        if h.isAlive()
            // Stunned
            if h.hasAbility('BPSE') or h.hasAbility('BSTN') or h.isPaused()
                if not stunned[bot]
                    stunned[bot] = true
                    lastOrders[bot] = h.getLastOrder()
            else
                if stunned[bot]
                    stunned[bot] = false
                    lastOrders[bot].issue()
            
            // Buy items
            if wannaBuy[bot]
                if not isAttacking[bot] and not goShopping[bot]
                    let shop = itemBuilds[bot].get().shop.getNearbyShop(h)
                    h.issuePointOrderById(Orders.smart, shop.getPos().polarOffset(shop.getFacingAngle() + 45..asAngleDegrees(), 300.))
                    goShopping[bot] = true
                    isRetreating[bot] = false
                else
                    if goShopping[bot]
                        nullTimer() ->
                            if not (h.getCurrentOrder() == Orders.move or h.getCurrentOrder() == Orders.smart)
                                doAfter(3.) ->
                                    let data = itemBuilds[bot].get()
                                    let shop = data.shop.getNearbyShop(h)
                                    IssueNeutralTargetOrderById(players[bot], shop, Orders.neutralinteract, h)

                                    if IssueNeutralImmediateOrderById(players[bot], shop, data.itm)
                                        itemBuilds[bot].itemWasBought()
                                    
                                    wannaBuy[bot] = false
                                    canAttack[bot] = true
                                    isRetreating[bot] = h.getHPRatio() < 0.3
                    goShopping[bot] = false
            
            // Attack
            if canAttack[bot]
                if not isRetreating[bot]
                    and (not isAttacking[bot]
                    or (not (h.getCurrentOrder() == Orders.move or h.getCurrentOrder() == Orders.smart)
                    and h.getCurrentOrder() != Orders.attack
                    and not isCasting[bot]))

                    let target = THE_DRAENEI.has(h) ? getRandomLastDr() : getRandomLastDe()
                    if target != null
                        h.issueTargetOrderById(Orders.patrol, target)
                        targetUnit[bot] = target
                        isAttacking[bot] = true
            if isAttacking[bot]
                if h.getHPRatio() < 0.35
                    canAttack[bot] = false
                    isAttacking[bot] = false
                    isRetreating[bot] = true
                else
                    if h.getCurrentOrder() != Orders.attack and not isCasting[bot]
                        let enemy = new Reference<unit>(null)
                        forUnitsInRange(h.getPos(), 500., u -> begin
                            if h.isEnemyOf(u.getOwner()) and u.isAlive()
                                enemy.val = u
                        end)
                        if enemy.into() != null
                            h.issuePointOrderById(Orders.attack, targetUnit[bot].getPos())
                    
                    // Retreat if there are too many enemy heroes
                    let allyHeroes = new Reference(0)
                    let enemyHeroes = new Reference(0)
                    forUnitsInRange(h.getPos(), 900., u -> begin
                        if u.isType(UNIT_TYPE_HERO) and u.isAlive()
                            if h.isAllyOf(u.getOwner())
                                allyHeroes.val++
                            else
                                enemyHeroes.val++
                    end)
                    if enemyHeroes.into() - allyHeroes.into() > 2
                        bot.retreatTemporally(3.)
                        
            if isRetreating[bot]
                h.issuePointOrderById(Orders.smart, (THE_DRAENEI.has(h) ? actDrSpawn : actDeSpawn).getCenter())
                if h.getHPRatio() > 0.8
                    isRetreating[bot] = false
                    canAttack[bot] = true
                else if (THE_DRAENEI.has(h) and actDrSpawn.contains(h.getPos())) or actDeSpawn.contains(h.getPos())
                    wannaBuy[bot] = not h.isInventoryFull()
    end)

    /*onBotHeroDie(bot -> begin
        canAttack[bot] = true
    end)*/

    onBotHeroRevive(bot -> begin
        wannaBuy[bot] = not hero[bot].isInventoryFull()
    end)

    onBotHeroAppear(bot -> begin
        itemBuilds[bot] = new ItemBuild(hero[bot])
    end)
    
    registerPlayerUnitEvent(EVENT_PLAYER_UNIT_SPELL_CAST, () -> begin
        let p = GetSpellAbilityUnit().getOwner()
        if p.isBot()
            isCasting[p.getId()] = true
    end)
    
    registerPlayerUnitEvent(EVENT_PLAYER_UNIT_SPELL_ENDCAST, () -> begin
        let p = GetSpellAbilityUnit().getOwner()
        if p.isBot()
            isCasting[p.getId()] = false
    end)
/*
    CreateTrigger()
        ..registerAnyUnitEvent(EVENT_PLAYER_UNIT_ISSUED_ORDER)
        ..registerAnyUnitEvent(EVENT_PLAYER_UNIT_ISSUED_UNIT_ORDER)
        ..addAction(() -> begin
            if GetOrderedUnit().isType(UNIT_TYPE_STRUCTURE)
                print(HEALING_SALVE.getNewId())
                print(GetIssuedOrderId().toString())
                //print(GetOrderedUnit().getName() + " " + GetIssuedOrderId().toString() + " " + GetOrderTargetUnit().getName() + " " + "\n")
        end)
*/