/*package DinamicEvents

import RegisterEvents
import LinkedList
import HashMap
import OnUnitEnterLeave
import UnitIndexer

trigger array t

class UnitEventData
    int hid
    trigger trg
    triggeraction ta
    DinamicEventListener del

let eventMap = new HashMap<unit, UnitEventData>()

public function unit.clearEvents()
    let data = eventMap.get(this)
    if data != null
        TriggerRemoveAction(data.trg, data.ta)
        destroy data.del
        destroy data

public abstract class DinamicEventListener
    protected LinkedList<DinamicEventListener> listeners
    protected int hid

    function reconnect()
        if not listeners.contains(this)
            listeners.add(this)

    function disconnect()
        listeners.remove(this)

    ondestroy
        disconnect()

// Unit kill / death event

HashMap<int, LinkedList<UnitKillClosure>> array unitKillEventMaps

let filterKill = Filter(() -> begin
    let index = GetKillingUnit().getIndex()
    for l in unitKillEventMaps[index].get(GetTriggerEventId().getHandleId())
        l.run(GetDyingUnit())
end)

public abstract class UnitKillClosure extends DinamicEventListener
    protected LinkedList<UnitKillClosure> listeners

    abstract function run(unit dead)

public function unit.registerKillEvent(UnitKillClosure c) returns DinamicEventListener
    let index = this.getIndex()
    let hid = EVENT_PLAYER_UNIT_DEATH.getHandleId()
    if unitKillEventMaps[index] == null
        unitKillEventMaps[index] = new HashMap<int, LinkedList<UnitKillClosure>>()
        unitKillEventMaps[index].put(hid, new LinkedList<UnitKillClosure>())
    unitKillEventMaps[index].get(hid).add(c)
    if t[hid] == null
        t[hid] = CreateTrigger()
        for k = bj_MAX_PLAYER_SLOTS - 1 downto 0
            t[hid].registerPlayerUnitEvent(players[k], EVENT_PLAYER_UNIT_DEATH, filterKill)
    c.hid = hid
    return c

HashMap<int, LinkedList<UnitDeathClosure>> array unitDeathEventMaps

let filterDeath = Filter(() -> begin
    let index = GetDyingUnit().getIndex()
    for l in unitDeathEventMaps[index].get(GetTriggerEventId().getHandleId())
        l.run(GetKillingUnit())
end)

public abstract class UnitDeathClosure extends DinamicEventListener
    protected LinkedList<UnitDeathClosure> listeners

    abstract function run(unit dead)

public function unit.registerDeathEvent(UnitDeathClosure c) returns DinamicEventListener
    let index = this.getIndex()
    let hid = EVENT_PLAYER_UNIT_DEATH.getHandleId()
    if unitDeathEventMaps[index] == null
        unitDeathEventMaps[index] = new HashMap<int, LinkedList<UnitDeathClosure>>()
        let list = new LinkedList<UnitDeathClosure>()
        unitDeathEventMaps[index].put(hid, list)
        c.listeners = list
    unitDeathEventMaps[index].get(hid).add(c)
    if t[hid] == null
        t[hid] = CreateTrigger()
        for k = bj_MAX_PLAYER_SLOTS - 1 downto 0
            t[hid].registerPlayerUnitEvent(players[k], EVENT_PLAYER_UNIT_DEATH, filterDeath)
    c.hid = hid
    return c

init
    onUnitDeindex(() -> begin
        getDeindexedUnit().clearEvents()
    end)*/