package DrAndDeSpawn

import UnitIndexer
import Orders

import DamageEngine
import Functions
import PlayerData
import initlater Missions

public boolean spawnRun = false

public constant group attackers = CreateGroup()
public constant int array DRAENEI_WARRIOR = [0, 'n002', 'n005', 'n00Q']
public constant int array DRAENEI_MAGE = [0, 0, 'n00B', 'n003']

public constant int array CHAOS_GRUNT = [0, 'n00D', 'n00F', 'n00S']
public constant int array CHAOS_WARLOCK = [0, 0, 'n017', 'n00R']

public constant attackPoint1 = gg_rct_Punto_de_ataque_1.getCenter()
public constant attackPoint2 = gg_rct_Punto_de_ataque_2.getCenter()
public constant attackPoint3 = gg_rct_Punto_de_ataque_3.getCenter()
public constant attackPoint4 = gg_rct_Punto_de_ataque_4.getCenter()

public constant drSpw = gg_rct_Spawneo_de_draeneanos.getCenter()
public constant deSpw1 = gg_rct_Spawneo_de_Grunts_1.getCenter()
public constant deSpw2 = gg_rct_Spawneo_de_Grunts_2.getCenter()
public constant deSpw3 = gg_rct_Spawneo_de_Grunts_3.getCenter()

public vec2 array target

let drUnits = CreateGroup()
let deUnits = CreateGroup()

int drInMap = 0
int deInMap = 0

let theyGo = CreateGroup()

let spawning = CreateTrigger()..disable()
let attack = CreateTrigger()..disable()
let changeTarget = CreateTrigger()..disable()
let cleaner = CreateTrigger()..disable()
DamageListener theyAreCowards

public function startSpawn()
    spawning.enable()
    attack.enable()
    theyAreCowards.reconnect()
    changeTarget.enable()
    cleaner.enable()

public function stopSpawn()
    spawning.disable()
    attack.disable()
    theyAreCowards.disconnect()
    changeTarget.disable()
    cleaner.disable()

function createDr(int id)
    if drInMap > 15
        return
    drInMap++
    let c = createUnit(DRAENEI, id, drSpw, UNIT_FACING)
    target[c.getIndex()] = attackPoint1
    c.issuePointOrderById(Orders.attack, attackPoint1)
    drUnits.addUnit(c)
    attackers.addUnit(c)

function createDe(int id, vec2 pos, vec2 t)
    if deInMap > 15
        return
    deInMap++
    let c = createUnit(DEMON, id, pos, UNIT_FACING)
    target[c.getIndex()] = t
    c.issuePointOrderById(Orders.attack, t)
    deUnits.addUnit(c)
    attackers.addUnit(c)

init
    // The units spawn
    spawning
        ..registerTimerEvent(30., true)
        .addAction(() -> begin
            if actMission == 1
                for i = 1 to 3
                    createDr(DRAENEI_WARRIOR[1])
                    createDe(CHAOS_GRUNT[1], deSpw1, attackPoint1)
            else if actMission == 2
                for i = 1 to 3
                    createDr(DRAENEI_WARRIOR[2])
                    createDe(CHAOS_GRUNT[2], deSpw2, attackPoint2)
                for i = 1 to 2
                    createDr(DRAENEI_MAGE[2])
                    createDe(CHAOS_WARLOCK[2], deSpw2, attackPoint2)
            else if actMission >= 3
                for i = 1 to 3
                    createDr(DRAENEI_WARRIOR[3])
                    createDe(CHAOS_GRUNT[3], deSpw3, attackPoint4)
                for i = 1 to 2
                    createDr(DRAENEI_MAGE[3])
                    createDe(CHAOS_WARLOCK[3], deSpw3, attackPoint4)
        end)
    // Keep the units attack their targets
    attack
        ..registerTimerEvent(2., true)
        .addAction(() -> begin
            attackers.forEachIn(u -> begin
                if not u.isAlive()
                    attackers.removeUnit(u)
                else if u.getCurrentOrder() == Orders.attack or theyGo.contains(u)
                    u.issuePointOrderById(Orders.attack, target[u.getIndex()])
                    theyGo.removeUnit(u)
            end)
        end)
    // If a creep wanna go back for taking damage from an ally
    theyAreCowards = registerAfterDamageEvent(damage -> begin
        if attackers.contains(damage.target) and
            damage.isSpell and
            damage.source.getOwner().isAllyOf(damage.target.getOwner())
            theyGo.addUnit(damage.target)
    end)..disconnect()
    // Clear the groups when the units die
    cleaner
        ..registerAnyUnitEvent(EVENT_PLAYER_UNIT_DEATH)
        ..addAction(() -> begin
            let u = GetDyingUnit()
            if drUnits.contains(u)
                drUnits.removeUnit(u)
                drInMap--
            else if deUnits.contains(u)
                deUnits.removeUnit(u)
                deInMap--
        end)
    // Actions when the prision door is destroyed
    CreateTrigger()
        ..registerDeathEvent(gg_dest_DTg3_0017)
        ..addAction(() -> begin
            forUnitsOfPlayer(DRAENEI, u -> begin
                if u.getTypeId() == DRAENEI_WARRIOR[1]
                    u.issuePointOrderById(Orders.attack, attackPoint1)
                    attackers.addUnit(u)
            end)
            forUnitsOfPlayer(DEMON, u -> begin
                if gg_rct_Punto_de_ataque_1.contains(u.getPos())
                    u.issuePointOrderById(Orders.attack, drSpw)
                    attackers.addUnit(u)
            end)
        end)