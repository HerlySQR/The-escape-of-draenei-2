package DrAndDeSpawn

import UnitIndexer
import Orders
import DamageEvent

import Functions
import Reset
import PlayerData
import initlater Missions

public boolean spawnRun = false

public constant group attackers = CreateGroup()
public constant int array DRAENEI_WARRIOR = [0, 'n002', 'n005', 'n00Q']
public constant int array DRAENEI_MAGE = [0, 0, 'n00B', 'n003']

public constant int array CHAOS_GRUNT = [0, 'n00D', 'n00F', 'n00S']
public constant int array CHAOS_WARLOCK = [0, 0, 'n017', 'n00R']

public constant attackPoint1 = Rects.attackPoint1.getCenter()
public constant attackPoint2 = Rects.attackPoint2.getCenter()
public constant attackPoint3 = Rects.attackPoint3.getCenter()
public constant attackPoint4 = Rects.attackPoint4.getCenter()
public constant attackPoint5 = Rects.attackPoint5.getCenter()

public constant drSpw = Rects.draeneiSpawn.getCenter()
public constant deSpw1 = Rects.demonSpawn1.getCenter()
public constant deSpw21 = Rects.demonSpawn21.getCenter()
public constant deSpw22 = Rects.demonSpawn21.getCenter()
public constant deSpw31 = Rects.demonSpawn31.getCenter()
public constant deSpw32 = Rects.demonSpawn31.getCenter()

public vec2 array target

let drUnits = CreateGroup()
let deUnits = CreateGroup()

int drInMap = 0
int deInMap = 0

let theyGo = CreateGroup()

let spawning = CreateTrigger()..disable()
let attack = CreateTrigger()..disable()
let changeTarget = CreateTrigger()..disable()
let cleaner = CreateTrigger()..disable()
DamageListener theyAreCowards

public function startSpawn()
    spawning.enable()
    attack.enable()
    DamageEvent.addListener(theyAreCowards)
    changeTarget.enable()
    cleaner.enable()

public function stopSpawn()
    spawning.disable()
    attack.disable()
    DamageEvent.removeListener(theyAreCowards)
    changeTarget.disable()
    cleaner.disable()

function createDr(int id)
    if drInMap > 15
        return
    drInMap++
    let c = createUnit(DRAENEI, id, drSpw, UNIT_FACING)
    target[c.getIndex()] = attackPoint1
    c.issuePointOrderById(Orders.attack, attackPoint1)
    drUnits.add(c)
    attackers.add(c)

function createDe(int id, vec2 pos, vec2 t)
    if deInMap > 15
        return
    deInMap++
    let c = createUnit(DEMON, id, pos, UNIT_FACING)
    target[c.getIndex()] = t
    c.issuePointOrderById(Orders.attack, t)
    deUnits.add(c)
    attackers.add(c)

init
    onReset(false, () -> begin
        forUnitsInRect(bj_mapInitialPlayableArea, u -> begin
            let id = u.getTypeId()
            for i = 1 to 3
                if id == DRAENEI_WARRIOR[i] or id == CHAOS_GRUNT[i]
                    u.remove()
            for i = 1 to 2
                if id == DRAENEI_MAGE[i] or id == CHAOS_WARLOCK[i]
                    u.remove()
        end)
    end)
    // The units spawn
    spawning
        ..registerTimerEvent(30., true)
        .addAction(() -> begin
            if actMission == 1
                for i = 1 to 3
                    createDr(DRAENEI_WARRIOR[1])
                    createDe(CHAOS_GRUNT[1], deSpw1, attackPoint1)
            else if actMission == 2
                for i = 1 to 3
                    createDr(DRAENEI_WARRIOR[2])
                    createDe(CHAOS_GRUNT[2], deSpw21, attackPoint2)
                for i = 1 to 2
                    createDr(DRAENEI_MAGE[2])
                    createDe(CHAOS_WARLOCK[2], deSpw22, attackPoint2)
            else if actMission >= 3
                for i = 1 to 3
                    createDr(DRAENEI_WARRIOR[3])
                    createDe(CHAOS_GRUNT[3], deSpw31, attackPoint4)
                for i = 1 to 2
                    createDr(DRAENEI_MAGE[3])
                    createDe(CHAOS_WARLOCK[3], deSpw32, attackPoint4)
        end)
    // Keep the units attack their targets
    attack
        ..registerTimerEvent(2., true)
        .addAction(() -> begin
            attackers.forEachIn(u -> begin
                if not u.isAlive()
                    attackers.remove(u)
                else if u.getCurrentOrder() == Orders.attack or theyGo.has(u)
                    u.issuePointOrderById(Orders.attack, target[u.getIndex()])
                    theyGo.remove(u)
            end)
        end)
    // If a creep wanna go back for taking damage from an ally
    theyAreCowards = () -> begin
        if attackers.has(DamageEvent.getTarget()) and
            DamageEvent.isSpell() and
            DamageEvent.getSource().getOwner().isAllyOf(DamageEvent.getTarget().getOwner())
            theyGo.add(DamageEvent.getTarget())
    end
    // Clear the groups when the units die
    cleaner
        ..registerAnyUnitEvent(EVENT_PLAYER_UNIT_DEATH)
        ..addAction(() -> begin
            let u = GetDyingUnit()
            if drUnits.has(u)
                drUnits.remove(u)
                drInMap--
            else if deUnits.has(u)
                deUnits.remove(u)
                deInMap--
        end)
    // Actions when the prision door is destroyed
    CreateTrigger()
        ..registerDeathEvent(Dests.dungeonDoor1)
        ..addAction(() -> begin
            forUnitsOfPlayer(DRAENEI, u -> begin
                if u.getTypeId() == DRAENEI_WARRIOR[1]
                    u.issuePointOrderById(Orders.attack, attackPoint1)
                    attackers.add(u)
            end)
            forUnitsOfPlayer(DEMON, u -> begin
                if Rects.attackPoint1.contains(u.getPos())
                    u.issuePointOrderById(Orders.attack, drSpw)
                    attackers.add(u)
            end)
        end)